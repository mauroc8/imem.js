{"version":3,"sources":["compileLegV8.ts","parseLegV8.ts","index.ts"],"names":[],"mappings":"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","file":"src.10ed1040.js","sourceRoot":"../src","sourcesContent":["\n// ---\n\ntype BinaryDigit = '0' | '1';\n\n// ---\n\ntype BinaryNumber = BinaryDigit[];\n\nfunction b(...args: (string | BinaryNumber)[]): BinaryNumber {\n    return args.flatMap(bHelper);\n}\n\nfunction bHelper(arg: string | BinaryNumber): BinaryNumber {\n    if (arg instanceof Array) {\n        return arg;\n    } else {\n        if (/[^01_]/.test(arg)) {\n            throw `El número ${arg} debería ser un número binario`;\n        }\n\n        return arg.replace(/_/g, '').split('') as BinaryNumber;\n    }\n\n}\n\nfunction decimalToBinary(number: number, amountOfBits: number): BinaryNumber {\n    if (number >= 0) {\n        return b(number.toString(2).padStart(amountOfBits, '0'));\n    } else {\n        return decimalToBinary(\n            Math.pow(2, amountOfBits) + number,\n            amountOfBits\n        );\n    }\n}\n\n// ---\n\ntype HexDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';\n\nfunction hexDigitToBinary(digit: HexDigit): BinaryNumber {\n    switch (digit) {\n        case '0': return b('0000');\n        case '1': return b('0001');\n        case '2': return b('0010');\n        case '3': return b('0011');\n        case '4': return b('0100');\n        case '5': return b('0101');\n        case '6': return b('0110');\n        case '7': return b('0111');\n        case '8': return b('1000');\n        case '9': return b('1001');\n        case 'A': return b('1010');\n        case 'B': return b('1011');\n        case 'C': return b('1100');\n        case 'D': return b('1101');\n        case 'E': return b('1110');\n        case 'F': return b('1111');\n    }\n}\n\n// ---\n\ntype Nibble = `${BinaryDigit}${BinaryDigit}${BinaryDigit}${BinaryDigit}`;\n\nfunction nibbleToHex(nibble: Nibble): HexDigit {\n    switch (nibble) {\n        case '0000': return '0';\n        case '0001': return '1';\n        case '0010': return '2';\n        case '0011': return '3';\n        case '0100': return '4';\n        case '0101': return '5';\n        case '0110': return '6';\n        case '0111': return '7';\n        case '1000': return '8';\n        case '1001': return '9';\n        case '1010': return 'A';\n        case '1011': return 'B';\n        case '1100': return 'C';\n        case '1101': return 'D';\n        case '1110': return 'E';\n        case '1111': return 'F';\n    }\n}\n\n// ---\n\ntype HexNumber = HexDigit[];\n\nfunction h(str: string): HexNumber {\n    if (/[^0123456789ABCDEF_]/.test(str)) {\n        throw `El número ${str} debería ser un número hexadecimal`;\n    }\n\n    return str.replace(/_/g, '').split('') as HexNumber;\n}\n\n\nfunction binaryToHex(binary: BinaryNumber): HexNumber {\n    if (binary.length < 4) {\n\n        if (binary.length !== 0) {\n            throw `binaryNumberToHex asume que el número ${binary.join('')} tiene length divisible por 4`;\n        }\n\n        return [];\n    } else {\n        const [a, b, c, d, ...rest] = binary;\n\n        const word: Nibble = `${a}${b}${c}${d}`;\n\n        try {\n            return [nibbleToHex(word), ...binaryToHex(rest)];\n\n        } catch (_) {\n            throw `binaryNumberToHex asume que el número ${binary.join('')} tiene length divisible por 4`;\n        }\n    }\n}\n\n// ---\n\nexport type Register = 'X0' | 'X1' | 'X2' | 'X3' | 'X4' | 'X5' | 'X6' | 'X7' | 'X8' | 'X9'\n    | 'X10' | 'X11' | 'X12' | 'X13' | 'X14' | 'X15' | 'X16' | 'X17' | 'X18' | 'X19'\n    | 'X20' | 'X21' | 'X22' | 'X23' | 'X24' | 'X25' | 'X26' | 'X27' | 'X28' | 'X29'\n    | 'X30' | 'XZR';\n\nconst XZR = 'XZR';\n\nfunction registerToBinary(register: Register): BinaryNumber {\n    if (register === 'XZR') {\n        return decimalToBinary(31, 5);\n    } else {\n        const match = register.match(/X(\\d+)/);\n\n        if (!match) {\n            throw `Invalid register ${register}`\n        }\n\n        const [_, d] = match;\n        const n = Number(d);\n\n        if (n < 0 || n > 30) {\n            throw `Invalid register ${register}`\n        }\n\n        return decimalToBinary(n, 5);\n    }\n}\n\n// ---\n\ntype SystemRegister = ExceptionReturnRegister | ExceptionLinkRegister | ExceptionSyndromeRegister;\n\ntype ExceptionReturnRegister = 'S2_0_C0_C0_0';\ntype ExceptionLinkRegister = 'S2_0_C1_C0_0';\ntype ExceptionSyndromeRegister = 'S2_0_C2_C0_0';\n\nfunction systemRegisterToBinary(systemRegister: SystemRegister): BinaryNumber {\n    switch (systemRegister) {\n        case 'S2_0_C0_C0_0':\n            return b('0000');\n\n        case 'S2_0_C1_C0_0':\n            return b('0001');\n\n        case 'S2_0_C2_C0_0':\n            return b('0010');\n    }\n}\n\n// ---\n\nexport type Instruction =\n    | { STUR: [Register, Register, number] }\n    | { LDUR: [Register, Register, number] }\n    | { ADD: [Register, Register, Register] }\n    | { SUB: [Register, Register, Register] }\n    | { AND: [Register, Register, Register] }\n    | { ORR: [Register, Register, Register] }\n    | { ADDI: [Register, Register, number] }\n    | { SUBI: [Register, Register, number] }\n    | { CBZ: [Register, string] }\n    | { ERET: [] }\n    | { NOP: [] }\n    | { MRS: [Register, SystemRegister] }\n    | { BR: [Register] }\n    | { INVALID_INSTRUCTION: [] }\n\nfunction encodeInstructionToBinary(instruction: Instruction, instructionIndex: number, labelIndex: Record<string, number>): BinaryNumber {\n    if ('STUR' in instruction) {\n        const [rt, rn, dtAddress] = instruction.STUR;\n\n        const opCode = '111_1100_0000';\n\n        return b(\n            opCode,\n            decimalToBinary(dtAddress, 9),\n            '00',\n            registerToBinary(rn),\n            registerToBinary(rt)\n        );\n    }\n\n    if ('LDUR' in instruction) {\n        const [rt, rn, dtAddress] = instruction.LDUR;\n\n        const opCode = '111_1100_0010';\n\n        return b(\n            opCode,\n            decimalToBinary(dtAddress, 9),\n            '00',\n            registerToBinary(rn),\n            registerToBinary(rt)\n        );\n    }\n\n    function rType(args: [Register, Register, Register]): BinaryNumber {\n        const [rd, rn, rm] = args;\n\n        return b(\n            registerToBinary(rm),\n            '000000', // shamt\n            registerToBinary(rn),\n            registerToBinary(rd)\n        );\n    }\n\n    function iType(args: [Register, Register, number]): BinaryNumber {\n        const [rd, rn, aluImm] = args;\n\n        return b(\n            decimalToBinary(aluImm, 12),\n            registerToBinary(rn),\n            registerToBinary(rd)\n        );\n    }\n\n    if ('ADD' in instruction) {\n        const opCode = '100_0101_1000';\n\n        return b(opCode, rType(instruction.ADD));\n    }\n\n    if ('SUB' in instruction) {\n        const opCode = '110_0101_1000';\n\n        return b(opCode, rType(instruction.SUB));\n    }\n\n    if ('AND' in instruction) {\n        const opCode = '100_0101_0000';\n\n        return b(opCode, rType(instruction.AND));\n    }\n\n    if ('ORR' in instruction) {\n        const opCode = '101_0101_0000';\n\n        return b(opCode, rType(instruction.ORR));\n    }\n\n    if ('ADDI' in instruction) {\n        const opCode = '100_1000_100';\n\n        return b(opCode, iType(instruction.ADDI));\n    }\n\n    if ('SUBI' in instruction) {\n        const opCode = '111_1000_100';\n\n        return b(opCode, iType(instruction.SUBI));\n    }\n\n    if ('CBZ' in instruction) {\n        const [rt, label] = instruction.CBZ;\n\n        if (typeof labelIndex[label] !== 'number') {\n            throw `Label inexistente: \"${label}\"`;\n        }\n\n        const condBrAddress = labelIndex[label] - instructionIndex;\n\n\n        const opCode = '101_1010_0';\n\n        return b(\n            opCode,\n            decimalToBinary(condBrAddress, 19),\n            registerToBinary(rt)\n        );\n    }\n\n    if ('ERET' in instruction) {\n        const opCode = '1101011_0100';\n\n        return b(\n            opCode,\n            '11111',\n            '000000',\n            '11111',\n            '00000'\n        );\n    }\n\n    if ('NOP' in instruction) {\n       return encodeInstructionToBinary({ ADD: [XZR, XZR, XZR] }, instructionIndex, labelIndex);\n    }\n\n    if ('MRS' in instruction) {\n        const [rt, systemRegister] = instruction.MRS;\n\n        const opCode = '11010101001';\n\n        return b(\n            opCode,\n            '10',\n            '000',\n            systemRegisterToBinary(systemRegister),\n            '0000',\n            '000',\n            registerToBinary(rt)\n        );\n    }\n\n    if ('BR' in instruction) {\n        const [rn] = instruction.BR;\n\n        const opCode = '1101011_0000';\n\n        return b(\n            opCode,\n            '11111',\n            '000000',\n            registerToBinary(rn),\n            '00000'\n        );\n    }\n\n    if ('INVALID_INSTRUCTION' in instruction) {\n        return repeat('0', 32);\n    }\n\n    throw `Invalid instruction: ${JSON.stringify(instruction)}`;\n}\n\nfunction encodeInstruction(instruction: Instruction, instructionIndex: number, labelIndex: Record<string, number>): HexNumber {\n    return binaryToHex(encodeInstructionToBinary(instruction, instructionIndex, labelIndex));\n}\n\nfunction instructionSource(instruction: Instruction): string {\n    if ('STUR' in instruction) {\n        const [rt, rn, dtAddress] = instruction.STUR;\n\n        const opCode = '111_1100_0000';\n\n        return `STUR ${rt}, [${rn}, #${dtAddress}]`;\n    }\n\n    if ('LDUR' in instruction) {\n        const [rt, rn, dtAddress] = instruction.LDUR;\n\n        const opCode = '111_1100_0010';\n\n        return `LDUR ${rt}, [${rn}, #${dtAddress}]`;\n\n    }\n\n    function rType(args: [Register, Register, Register]): string {\n        const [rd, rn, rm] = args;\n\n        return `${rd}, ${rn}, ${rm}`;\n    }\n\n    function iType(args: [Register, Register, number]): string {\n        const [rd, rn, aluImm] = args;\n\n        return `${rd}, ${rn}, #${aluImm}`;\n    }\n\n    if ('ADD' in instruction) {\n        return `ADD ${rType(instruction.ADD)}`;\n    }\n\n    if ('SUB' in instruction) {\n        return `SUB ${rType(instruction.SUB)}`;\n    }\n\n    if ('AND' in instruction) {\n        return `AND ${rType(instruction.AND)}`;\n    }\n\n    if ('ORR' in instruction) {\n        return `ORR ${rType(instruction.ORR)}`;\n    }\n\n    if ('ADDI' in instruction) {\n        return `ADDI ${iType(instruction.ADDI)}`;\n    }\n\n    if ('SUBI' in instruction) {\n        return `SUBI ${iType(instruction.SUBI)}`;\n    }\n\n    if ('CBZ' in instruction) {\n        const [rt, label] = instruction.CBZ;\n\n        return `CBZ ${rt}, ${label}`;\n    }\n\n    if ('ERET' in instruction) {\n        return `ERET`;\n    }\n\n    if ('NOP' in instruction) {\n        return `NOP`;\n    }\n\n    if ('MRS' in instruction) {\n        const [rt, systemRegister] = instruction.MRS;\n\n        return `MRS ${rt}, ${systemRegister}`;\n    }\n\n    if ('BR' in instruction) {\n        const [rn] = instruction.BR;\n\n        return `BR ${rn}`;\n    }\n\n    if ('INVALID_INSTRUCTION' in instruction) {\n        return 'INVALID_INSTRUCTION';\n    }\n\n    return `???`;\n}\n\n// ---\n\nexport type Program = (Instruction | string)[];\n\nfunction encode(...originalProgram: Program): { hex: string, source: string }[] {\n    const labelIndex: Record<string, number> = {};\n\n    // a copy to avoid mutating the original program\n    const program = [...originalProgram];\n\n    for (let i = 0; i < program.length; i += 1) {\n        const label = program[i];\n\n        if (typeof label === 'string') {\n            if (label in labelIndex) {\n                throw `El label \"${label}\" está duplicado`;\n            }\n\n            labelIndex[label] = i;\n\n            program.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return (program as Instruction[])\n        .map((instruction, index) => ({\n            hex: encodeInstruction(instruction, index, labelIndex).join(''),\n            source: instructionSource(instruction),\n        }));\n}\n\nexport function compileLegV8(...program: Program): { hex: string, source: string }[] {\n    return encode(...program).map(instruction => ({ hex: `32'h${instruction.hex}`, source: instruction.source }));\n}\n\nconst NOP: Instruction = { NOP: [] };\n\nfunction repeat<A>(value: A, n: number): A[] {\n    if (n <= 0) {\n        return [];\n    } else {\n        return [value, ...repeat(value, n - 1)];\n    }\n}\n\nexport function compileLegV8WithIRS(program: Program, exceptionVector: Program): { hex: string, source: string }[] {\n    const instructionCount = program.reduce(\n        (sum, instructionOrLabel) => typeof instructionOrLabel !== 'string'\n            ? sum + 1\n            : sum,\n        0\n    );\n\n    if (instructionCount >= 54) {\n        throw 'El programa tiene más de 54 instrucciones y sobreescribe el vector de excepciones';\n    }\n\n    return compileLegV8(\n        ...program,\n        ...repeat(NOP, 54 - instructionCount),\n        // El vector de excepciones está en la instrucción nro 54\n        ...exceptionVector,\n    );\n}\n\n","import { compileLegV8, compileLegV8WithIRS, Instruction, Program, Register } from \"./compileLegV8\";\n\n\n\nexport function parseLegV8(code: string, isr: string): { code: string, romSize: number } {\n    const codeLines = code.split('\\n')\n    const isrLines = isr.trim() ? isr.split('\\n') : null\n\n    try {\n        const codeInstructions = codeLines.flatMap(parseLine)\n        const compiledCode =\n            isrLines\n                ? compileLegV8WithIRS(codeInstructions, isrLines.flatMap(parseLine))\n                : compileLegV8(...codeInstructions);\n\n        const ident = '           ';\n\n        return {\n            code: `'{\n${ident}${compiledCode.map(instr => `// ${instr.source}\\n${ident}${instr.hex}`).join(`,\\n${ident}`)}\n        };`,\n            romSize: compiledCode.length,\n        }\n    } catch (error) {\n        if (typeof error === 'string') {\n            return {\n                code: `\n           ${error}\n`, romSize: 0\n            }\n        } else {\n            throw error\n        }\n    }\n}\n\nfunction parseLine(line: string, index: number): Program {\n    // Untrimmed lines\n\n    if (line !== line.trim()) {\n        return parseLine(line.trim(), index)\n    }\n\n    // Empty lines\n\n    if (line.length === 0) {\n        return []\n    }\n\n    // Labels\n\n    const labelRegExp = /^(\\w+):/\n\n    const labelMatch = line.match(labelRegExp)\n\n    if (labelMatch) {\n        const [match, label] = labelMatch\n\n        return [\n            label,\n            // we continue parsing the rest of the line\n            ...parseLine(line.substring(match.length), index)\n        ]\n    }\n\n    // R-type\n\n    const rTypeRegExp = /^(ADD|SUB|AND|ORR)\\s+(X\\d{1,2}|XZR),\\s*(X\\d{1,2}|XZR),\\s*(X\\d{1,2}|XZR)$/\n\n    const rTypeMatch = line.match(rTypeRegExp)\n\n    if (rTypeMatch) {\n        const [_, op, rd, rn, rm] = rTypeMatch\n\n        if (validateRegister(rd)\n            && validateRegister(rn)\n            && validateRegister(rm)) {\n            switch (op) {\n                case 'ADD':\n                    return [{ ADD: [rd, rn, rm] }]\n\n                case 'SUB':\n                    return [{ SUB: [rd, rn, rm] }]\n\n                case 'AND':\n                    return [{ AND: [rd, rn, rm] }]\n\n                case 'ORR':\n                    return [{ ORR: [rd, rn, rm] }]\n            }\n        }\n\n        throw `Instrucción tipo R inválida en la línea ${index}: \"${line}\"`\n    }\n\n    // I-type\n\n    const iTypeRegExp = /^(ADDI|SUBI)\\s+(X\\d{1,2}|XZR),\\s*(X\\d{1,2}|XZR),\\s*#(\\d+)$/\n\n    const iTypeMatch = line.match(iTypeRegExp)\n\n    if (iTypeMatch) {\n        const [_, op, rd, rn, aluImm] = iTypeMatch\n\n        if (validateRegister(rd)\n            && validateRegister(rn)) {\n            switch (op) {\n                case 'ADDI':\n                    return [{ ADDI: [rd, rn, Number(aluImm)] }]\n\n                case 'SUBI':\n                    return [{ SUBI: [rd, rn, Number(aluImm)] }]\n            }\n        }\n\n        throw `Instrucción tipo I inválida en la línea ${index}: \"${line}\"`\n    }\n\n\n    // LDUR/STUR\n\n    const dTypeRegex = /^(LDUR|STUR)\\s+(X\\d{1,2}|XZR),\\s*\\[\\s*(X\\d{1,2}|XZR),\\s*#(-?\\d+)\\s*\\]$/\n\n    const dTypeMatch = line.match(dTypeRegex)\n\n    if (dTypeMatch) {\n        const [_, op, rt, rn, dtAddr] = dTypeMatch\n\n        if (validateRegister(rt) && validateRegister(rn)) {\n            switch (op) {\n                case 'LDUR':\n                    return [{ LDUR: [rt, rn, Number(dtAddr)] }]\n\n                case 'STUR':\n                    return [{ STUR: [rt, rn, Number(dtAddr)] }]\n            }\n        }\n\n        throw `Instrucción tipo D inválida en la línea ${index}: \"${line}\"`\n    }\n\n    // CBZ\n\n    const cbzRegex = /^CBZ\\s+(X\\d{1,2}|XZR),\\s*(\\w+)$/\n\n    const cbzMatch = line.match(cbzRegex)\n\n    if (cbzMatch) {\n        const [_, rt, label] = cbzMatch\n\n        if (validateRegister(rt)) {\n            return [{ CBZ: [rt, label] }]\n        }\n\n        throw `Instrucción CBZ inválida en la línea ${index}: \"${line}\"`\n    }\n\n    // ERET\n\n    const eretRegex = /^ERET$/\n\n    const eretMatch = line.match(eretRegex)\n\n    if (eretMatch) {\n        return [{ ERET: [] }]\n    }\n\n    // NOP\n\n    const nopRegex = /^NOP$/\n\n    const nopMatch = line.match(nopRegex)\n\n    if (nopMatch) {\n        return [{ NOP: [] }]\n    }\n\n    // BR\n\n    const brRegex = /^BR\\s+(X\\d{1,2}|XZR)$/\n\n    const brMatch = line.match(brRegex)\n\n    if (brMatch) {\n        const [_, rt] = brMatch\n\n        if (validateRegister(rt)) {\n            return [{ BR: [rt] }]\n        }\n\n        throw `Instrucción BR inválida en la línea ${index}: \"${line}\"`\n    }\n\n    // BR\n\n    const mrsRegExp = /^MRS\\s+(X\\d{1,2}|XZR),\\s*(S2_0_C[012]_C0_0)$/\n\n    const mrsMatch = line.match(mrsRegExp)\n\n    if (mrsMatch) {\n        const [_, rt, systemRegister] = mrsMatch\n\n        if (validateRegister(rt)\n            && (systemRegister === 'S2_0_C0_C0_0'\n                || systemRegister === 'S2_0_C1_C0_0'\n                || systemRegister === 'S2_0_C2_C0_0'\n            )\n        ) {\n            return [{ MRS: [rt, systemRegister] }]\n        }\n\n        throw `Instrucción MRS inválida en la línea ${index}: \"${line}\"`\n    }\n\n    if (line === 'INVALID_INSTRUCTION') {\n        return [{ INVALID_INSTRUCTION: [] }]\n    }\n\n    // Comentarios\n\n    if (line.startsWith('//')) {\n        return []\n    }\n\n    throw `Instrucción inválida en la línea ${index}: \"${line}\"`\n}\n\nfunction validateRegister(register: string): register is Register {\n    return range(0, 30).map(n => `X${n}`).includes(register) || register === 'XZR'\n}\n\nfunction range(start: number, end: number): number[] {\n    return Array.from({ length: end - start + 1 }).map((_, n) => n + start);\n}\n","import { parseLegV8 } from \"./parseLegV8\"\n\nwindow.addEventListener('DOMContentLoaded', main)\n\nfunction main() {\n    const codeOutput = document.querySelector('#code-output')\n    const romSizeOutput = document.querySelector('#rom-size-output')\n    const codeInput = document.querySelector<HTMLTextAreaElement>('#code-input')\n    const isrInput = document.querySelector<HTMLTextAreaElement>('#isr-input')\n    const copyOutputButton = document.querySelector<HTMLButtonElement>('#copy-output-button')\n    const output = document.querySelector('#output')\n\n    if (!codeOutput || !codeInput || !isrInput || !romSizeOutput || !copyOutputButton || !output) {\n        alert('Error: node not found')\n        throw { codeOutput, codeInput, isrInput, romSizeOutput, copyOutputButton, output }\n    }\n\n    initializeApp({ codeOutput, isrInput, codeInput, romSizeOutput, copyOutputButton, output })\n}\n\nfunction initializeApp({\n    codeInput,\n    isrInput,\n    codeOutput,\n    romSizeOutput,\n    copyOutputButton,\n    output,\n}: {\n    codeInput: HTMLTextAreaElement,\n    isrInput: HTMLTextAreaElement,\n    codeOutput: Element,\n    romSizeOutput: Element,\n    copyOutputButton: HTMLButtonElement,\n    output: Element,\n}) {\n    // --- persist input\n\n    persistInputValue('code-input', codeInput);\n    persistInputValue('isr-input', isrInput);\n\n    // --- update output\n\n    function updateOutput() {\n        const { code, romSize } = parseLegV8(codeInput.value, isrInput.value);\n        romSizeOutput.textContent = String(romSize - 1);\n        codeOutput.textContent = code;\n    }\n\n    const updateOutputDebounced = debounce(updateOutput, 450)\n\n    updateOutputDebounced()\n\n    codeInput.addEventListener('input', updateOutputDebounced)\n    isrInput.addEventListener('input', updateOutputDebounced)\n\n    // --- copy output button\n\n    copyOutputButton.addEventListener('click', () => {\n        navigator.clipboard.writeText(output.textContent || '')\n    })\n}\n\nfunction persistInputValue(key: string, input: HTMLTextAreaElement) {\n    const loadedCodeInput = localStorage.getItem(key)\n\n    if (loadedCodeInput) {\n        input.value = loadedCodeInput\n    }\n\n    function saveInput() {\n        localStorage.setItem(key, input.value)\n    }\n\n    const saveInputDebounced = debounce(saveInput, 800)\n\n    input.addEventListener('input', saveInputDebounced)\n}\n\nfunction debounce(fn, ms) {\n    let timeout\n\n\n    return () => {\n        if (timeout) {\n            clearTimeout(timeout)\n        }\n\n        timeout = setTimeout(() => {\n            fn()\n            timeout = null\n        }, ms)\n    }\n}\n"]}